#!/usr/bin/env python3
"""
Main exe for scoring simulations against mapped trajectories
"""
import argparse
from glob import glob
import numpy as np
import MDAnalysis as mda
import vermouth.forcefield
import fast_forward
from fast_forward.compute_bonded import compute_value_for_interaction
from fast_forward.itp_to_ag import itp_to_ag
from fast_forward.itp_parser_sub import read_itp

VERSION = 'fast_forward version {}'.format(fast_forward.__version__)


def hellinger(p,q):
    return np.round(np.sqrt(np.sum(np.power((np.sqrt(p) - np.sqrt(q)),2))) / np.sqrt(2),2)

def report(h_score_dict, h_score):
    buff = []
    add = buff.append

    add(" [ Interaction Distribution Report ]\n")
    add("   Overall Score : {mean:.2f} Â± {std:.2f}\n".format(mean=np.array(h_score).mean(),
                                                             std =np.array(h_score).std()))
    add(" Interaction Scores:")
    add(" 0 - identical, 1 - no overlap")
    for interaction_type in h_score_dict.keys():
        add(f" {interaction_type} ")
        for interaction_name, score in h_score_dict[interaction_type].items():
            add(f"\t{interaction_name:20s}: {score:.2f}")

    print('\n'.join(buff))
    with open('report.out', 'w') as fout:
        fout.writelines('\n'.join(buff))


BINS_DICT = {"bonds": np.arange(0, 7, 0.01),
             "angles": np.arange(181),
             "dihedrals": np.arange(-180, 181)
             }

def __main__():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,)
    parser.add_argument('-f', type=str, dest="trajfile", help="simulated trajectory file")
    parser.add_argument('-s', type=str, dest="tprfile", help="simulated tpr file", default=None)
    parser.add_argument('-i', type=str, dest="itp_files", help="itp file", nargs='*')
    parser.add_argument('-d', type=str, dest='reference',
                        help="Path to directory with reference distributions")
    parser.add_argument('-n', type=str, dest="ndx_file", help="index file")

    args = parser.parse_args()

    distribution_files = glob(f'{args.reference}/*distr.dat')

    # load trajectory
    if args.tprfile:
        u = mda.Universe(args.tprfile, args.trajfile, in_memory=True)
    else:
        u = mda.Universe(args.trajfile, in_memory=True)

    # if itp file is provided use it
    if args.itp_files:
        ff = vermouth.forcefield.ForceField("dummy")
        for file_handle in args.itp_files:
            with open(file_handle) as _file:
                lines = _file.readlines()
        read_itp(lines, ff)

        h_score = []

        h_score_dict = {'bonds': {},
                        'angles': {},
                        'dihedrals': {}}
        # loop over molecules
        for molname, block in ff.blocks.items():
            interaction_groups = itp_to_ag(block, molname, u)
            for inter_type in ['bonds', 'angles', 'dihedrals']:
                for group_name, pair_idxs in interaction_groups[inter_type].items():
                    time_series = compute_value_for_interaction(u, inter_type, pair_idxs)
                    # calculate simulation distribution
                    probs, edges = np.histogram(time_series, density=True, bins=BINS_DICT[inter_type])
                    center_points = edges[:-1] + np.diff(edges)/2.
                    distr = np.transpose((center_points, probs))

                    reference_data = np.loadtxt([i for i in distribution_files if group_name in i and inter_type in i][0])

                    score = hellinger(probs/probs.sum(), reference_data.T[1] / reference_data.T[1].sum())
                    h_score.append(score)

                    h_score_dict[inter_type][group_name] = score

        report(h_score_dict, h_score)


__main__()
