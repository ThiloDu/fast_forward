#!/usr/bin/env python3

# Copyright 2020 University of Groningen
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Main exe for computing interactions.
"""
import argparse
import pathlib
import numpy as np
import MDAnalysis as mda
import vermouth.forcefield
import sys
import fast_forward
from fast_forward.itp_to_ag import itp_to_ag
from fast_forward.itp_parser_sub import read_itp
from collections import defaultdict
from fast_forward.bonded_file_parser import read_bonds
from fast_forward.virtual_site_calculator import vs_handler, mass_redistribution
from fast_forward.interaction_fit import interaction_fitter
from fast_forward.interactions_to_itp import itp_writer
from fast_forward.interaction_distribution import interaction_distribution
from fast_forward.interaction_plots import make_distribution_plot

VERSION = 'fast_forward version {}'.format(fast_forward.__version__)

def __main__():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,)
    parser.add_argument('-f', type=str, dest="trajfile", help="trajectory file")
    parser.add_argument('-s', type=str, dest="tprfile", help="tpr file", default=None)
    parser.add_argument('-n', type=str, dest="ndx_file", help="index file")
    parser.add_argument('-pref', type=str, dest="prefix", help="common prefix to filename", default="")
    parser.add_argument('-i', type=str, dest="itp_files", help="itp file", nargs='*')
    parser.add_argument('-b', type=pathlib.Path, dest="bond_file", help="itp file")
    parser.add_argument('-plots', default=False, action="store_true",
                        dest="plots", help="save the fits of bonded interactions")
    parser.add_argument('-plot-data', default=False, action="store_true",
                        dest="plot_data", help="save a pickle file containing the input data for the plots")
    parser.add_argument('-name', default='mol', dest="molname", help="name of mapped molecule")
    parser.add_argument('-constraints', dest='constraint_convert', default=10000, type=int,
                        help="force constant above which to convert bonds to constraints")
    parser.add_argument('-precision', dest='precision', default=3, type=int,
                        help='precision of variables written to itp')

    args = parser.parse_args()

    # load trajectory
    if args.tprfile:
        u = mda.Universe(args.tprfile, args.trajfile, in_memory=True)
    else:
        u = mda.Universe(args.trajfile, in_memory=True)

    # if itp file is provided use it
    if args.itp_files:
        ff = vermouth.forcefield.ForceField("dummy")
        for file_handle in args.itp_files:
            with open(file_handle) as _file:
                lines = _file.readlines()
        read_itp(lines, ff)

        # loop over molecules
        for molname, block in ff.blocks.items():
            interaction_groups = itp_to_ag(block, molname, u)
            for inter_type in ['bonds', 'angles', 'dihedrals']:
                for group_name, pair_idxs in interaction_groups[inter_type].items():
                    interaction_distribution(u, inter_type, pair_idxs, group_name, args.prefix)

    if args.bond_file:
        bonded_interactions, atomtypes = read_bonds(args.bond_file)
        interactions_dict = defaultdict(dict)
        for interaction in bonded_interactions.keys():
            for atom_list in bonded_interactions[interaction]:
                # need this to make sure we have the correct [name, index] pairings
                indices = []
                for atom in atom_list:
                    idx = u.select_atoms(f'name {atom}').indices[0]
                    indices.append(idx)

                # need to treat virtual sites separately
                if 'virtual_site' not in interaction:
                    # calculate distributions
                    distr = interaction_distribution(u, interaction, [np.array(indices)],
                                                     '_'.join(atom_list), args.prefix)

                    # fit the distributions for the interaction
                    value, sigma, fit_result = interaction_fitter(distr, interaction, args.precision)

                    if args.plots:
                        make_distribution_plot(distr, fit_result, '_'.join(atom_list), interaction, args.plot_data)


                    # check bonds if they should become constraints
                    if (interaction == "bonds") and sigma > args.constraint_convert:
                        interactions_dict["constraints"]['_'.join(atom_list)] = [value, sigma], indices
                    else:
                        interactions_dict[interaction]['_'.join(atom_list)] = [value, sigma], indices

                else:
                    # calculate virtual site position
                    params, indices = vs_handler(interaction, u, indices, '_'.join(atom_list),
                                                 args.prefix, plot=args.plots)

                    interactions_dict[interaction]['_'.join(atom_list)] = params, indices

                    atomtypes = mass_redistribution(atomtypes, atom_list)

        if args.molname:
            molname = args.molname
        else:
            molname = list(set(u.atoms.moltypes))[0]

        itp_writer(interactions_dict, atomtypes, molname, command_used=' '.join(sys.argv))

__main__()
