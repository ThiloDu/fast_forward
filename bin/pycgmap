#!/usr/bin/env python3

# Copyright 2020 University of Groningen
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Perform the parsing and input redirect for the
different subcommands. This is the main executable.
"""
import argparse
import pathlib
import numpy as np
import numba
import MDAnalysis as mda
import vermouth
from vermouth.file_writer import open, DeferredFileWriter
import vermouth.forcefield
import pycgmap
from pycgmap.mapping import create_new_universe, forward_map_positions
from pycgmap.universe_handler import UniverseHandler
from pycgmap.map_file_parers import read_mapping

VERSION = 'pycgmap version {}'.format(pycgmap.__version__)

def main():
    """
    Parses commandline arguments and perform transformation.
    """

    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument('-V', '--version', action='version', version=VERSION)


    file_group = parser.add_argument_group('Input Files')
    file_group.add_argument('-f', dest='traj', required=True, type=str,
                            help='trajectory file (XTC/TRR/GRO/PDB ...)')
    file_group.add_argument('-s', dest='tpr', required=True, type=str,
                            help='GROMACS tpr file (TPR)')
    file_group.add_argument('-mols', dest='mol_names', required=True, type=str, nargs='+',
                            help='molecule names to be considered')
    file_group.add_argument('-itps', dest='itps', required=False, type=list, nargs='+',
                            help='proto itp files for all molecules in form molname:itpfile')
    file_group.add_argument('-o', dest='outpath', type=str,
                            help='output ITP (ITP)')
    file_group.add_argument('-n', dest='index', type=str,
                            help='index file (NDX)')
    file_group.add_argument('-npdbs', dest='npdbs', type=str,
                            help='index file (NDX)', nargs='*')
    file_group.add_argument('-mf', dest='map_file', type=str,
                            help='mapping_file')

    mapping_group = parser.add_argument_group('Mapping Options')
    mapping_group.add_argument('-mode', dest='mode', required=False, type=str,
                               help='COG or COM mapping', default='COG')
    mapping_group.add_argument('-pbc', dest='pbc_complete', required=False, type=bool,
                               help='complete pbc with MDAnalysis; this is slow!', default=False)
    mapping_group.add_argument('-cores', dest='ncores', required=False, type=int,
                               help='number of cores to use for mapping', default=1)
    mapping_group.add_argument('-merge', dest='merge', required=False, action='store_true',
                               help='Find equivalent bonds/angles/dihedrals and merge them.')
    mapping_group.add_argument('-T', dest='temp', required=False, default=298.15,
                               help='temperature')
    mapping_group.add_argument('-method', dest='inter_mode', required=False, type=str,
                               help='', default='modf_boltz')
    args = parser.parse_args()

    print("INFO - Loading universe")
    # load trajectory
    init_universe = UniverseHandler(args.mol_names,
                                    args.tpr,
                                    args.traj,
                                    in_memory=True)
    if args.pbc_complete:
        print("INFO - PBC completeing trajectory")
        init_universe.pbc_complete()

    print("INFO - Loading mapping files")
    with open(args.map_file, "r") as _file:
        lines = _file.readlines()
    mappings = read_mapping(lines)[0]

    print("INFO - Mapping universe - indices")
    # first mapp the atom indices
    mapped_atoms, bead_idxs = pycgmap.mapping.forward_map_indices(init_universe,
                                                                  mappings)
    n_frames = len(init_universe.trajectory)

    print("INFO - Mapping universe - positions")
    mapped_atoms = numba.typed.List(mapped_atoms)
    bead_idxs = numba.typed.List(bead_idxs)

    # extract the position array from universe
    # if it's not a trajectory we have to emulate
    # a single frame
    path = pathlib.Path(args.traj)
    file_extension = path.suffix.casefold()[1:]
    if file_extension in ["xtc", "trr"]:
        positions = init_universe.trajectory.coordinate_array
    else:
        positions = init_universe.atoms.positions
        positions = positions.reshape(1, -1, 3)

    mapped_trajectory = forward_map_positions(mapped_atoms, bead_idxs, positions, n_frames, args.mode)

    print("INFO - Mapping universe - building pos-array")
    print(mapped_trajectory)
    cg_universe = create_new_universe(init_universe, mapped_trajectory, mappings)

    # write coordinate
    print("INFO - Writing CG trajectory")
    if args.traj:
        path = pathlib.Path(args.traj)
        file_extension = path.suffix.casefold()[1:]
    else:
        file_extension = "xtc"

    if file_extension in ["xtc", "trr"]:
        cg_beads = cg_universe.atoms
        with mda.Writer(args.outpath,
                        multiframe=True,
                        n_atoms=len(cg_universe.atoms)) as mapped:
            for time_step in cg_universe.trajectory:
                mapped.write(cg_beads)
    else:
        cg_universe.atoms.positions = cg_universe.trajectory.coordinate_array[0]
        cg_beads = cg_universe.atoms
        cg_universe.atoms.dimensions = init_universe.atoms.dimensions
        with mda.Writer(args.outpath,
                        n_atoms=len(cg_universe.atoms)) as mapped:
                mapped.write(cg_beads)


    # load itp file(s) if there are any
    #force_field = vermouth.forcefield.ForceField("CG_FF")
    #for filepath in args.itps:
    #    with open(filepath) as _file:
    #        lines = _file.readlines()
    #    vermouth.gmx.itp_read.read_itp(lines, force_field=force_field)

    # if redundant is ture find redudant interacitons
    #if args.merge:
    #   print("Cannot do this yet.")

    # compute bonds angles etc.
    #print("INFO - Computing interactions")
    #const = 8.314462*10**-3.0
    #pycgmap.calc_inter.compute_interaction_parameters(cg_universe,
    #                                                  molecule,
    #                                                  mode=args.inter_mode,
    #                                                  temp=args.temp,
    #                                                  gas_const=const)
    # write itp-file
    #with open("cg_out.itp", 'w') as outpath:
    #    vermouth.gmx.itp.write_molecule_itp(molecule, outpath,
    #                                        moltype=molecule.name,
    #                                        header=["pycgmap generated itp"])
    #DeferredFileWriter().write()
if __name__ == '__main__':
    main()
